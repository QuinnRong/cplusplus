第四章 表达式

表达式由一个或多个运算对象(operand)组成，对其求值将得到一个结果(result)
简单表达式 --> 字面值或变量
复杂表达式 --> 用运算符(operator)将一个或多个运算对象组合起来
复合表达式 --> 含两个或多个运算符的表达式

优先级表
::
., ->, [], 函数调用(), 类型构造()
后置++, 后置--, typeid, explicit cast
前置++, 前置--, ~, !, 一元-, 一元+, 解引用*, 取地址&, 类型转换(), sizeof, new, new[], delete, delete[], noexcept
->*, .*
乘法*, /, %
加法+, 减法-
<<, >>
<, <=, >, >=
==, !=
位与&
^
|
&&
||
? : 
=
*=, /=, %=, +=, -=, <<=, >>=, &=, |=, ^=
throw
,

/**********
4.1 基础
**********/
4.1.1 基本概念
运算对象个数 --> 一元运算符、二元运算符、三元运算符、特殊运算符(函数调用)
运算对象类型 --> 作为右值(rvalue)用的是对象的值(内容)，作为左值(lvalue)用的是对象的身份(内存中的位置)
运算符重载   --> 无法改变运算对象个数、优先级和结合律

4.1.2 优先级和结合律
如果优先级(precedence)相同，组合规则由结合律(associativity)确定(左结合或右结合)

4.1.3 求值顺序
只有四种运算符规定了求值顺序，对于其他运算符，若指向并修改了同一对象，结果是未定义的，例如 cout << i << " " << ++i << endl;
1) &&
2) ||
3) ?:
4) ,

/**********
4.2 算术运算符
**********/
一元+，一元-; *, /, %; +, -;
左结合律，求值结果都是右值
作用于任意算数类型和指针类型，求值前，所有运算对象转换成同一类型 --> 小整数类型(bool, char, short等)会被提升成较大的整数类型(int)
溢出的结果是未定义的
整数相除余数向0取整 --> 若m!=TMIN，则(-m)/n == m/(-n) == -(m/n)							/* c++11 */
(m/n)*n + m%n == m       --> 若m%n不为零，则符号和m相同 --> (-m)%n == -m%n, m%(-n) == m%n

/**********
4.3 逻辑和关系运算符
**********/
!; <, <=, >, >=; ==, !=; &&; ||;
除了!是右结合律，其余都是左结合律，求值结果都是右值布尔类型
关系运算符作用于算数类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型(0 -> false, 其余 -> true)
&& 和 || 短路求值

/**********
4.4 赋值运算符
**********/
=; *=, /=, %=, +=, -=, <<=, >>=, &=, |=, ^=; //throw; ,;//
右结合律，求值结果为左侧运算对象
初始化而非赋值 --> int i = 0; const int ci = i;
赋值时，左侧运算对象必须是一个可修改的左值，右侧运算对象将转换成左侧运算对象的类型
右侧运算对象可以是花括号括起来的初始值列表，不能窄化转换，采用值初始化 --> i = {3.14}; 错误	/* c++11 */
优先级较低，后面只有throw和，两种运算符

/**********
4.5 递增和递减运算符
**********/
后置++, 后置--; 前置++, 前置--;
后置版本优先级大于前置版本，前置版本优先级和解引用运算符相同
作用于左值对象，前置版本求值结果是更新后的左值，后置版本是更新前副本右值
前置版本可避免不必要的工作：存储原始值
后置版本在和解引用混用时更加简洁 --> iter = v.begin(); while(iter != v.end()) cout << *iter++ << endl;

/**********
4.6 成员访问运算符
**********/
//::;// ., ->;
左结合律，优先级仅在作用域运算符之后
ptr->mem 等价于 (*ptr).mem

/**********
4.7 条件运算符
**********/
?:
优先级在||之后，在=之前
右结合律 --> (grade > 90) ? "high" : (grade < 60) ? "fail" : "pass"; --> 右侧构成左侧分支
短路求值
两个表达式都为左值时，返回左值，否则返回右值

/**********
4.8 位运算符
**********/
~; <<, >>; &; ^; |;
移位运算符优先级在算数运算符之后，在关系运算符之前
和算数运算符一样，左结合，整型提升
右侧运算对象必须是非负的，而且小于结果的位数
左侧运算对象若是负数，会产生未定义的行为

/**********
4.9 sizeof运算符
**********/
sizeof (type), sizeof expr;
返回表达式或类型所占的字节数，返回值是常量表达式
sizeof (Class)
sizeof Class::mem; --> 无需通过类对象														/* c++11 */
sizeof 指针        --> 指针本身所占空间
sizeof *指针       --> 所指向对象所占空间大小，指针不需要有效
sizeof 数组        --> 不会转换成指针，而是计算整个数组所占空间大小
sizeof string or vector --> 返回固定部分大小(已分配空间)，而不是元素所占空间

/**********
4.10 逗号运算符
**********/
,
从左往右的顺序计算，返回右侧表达式的值
常用于for循环中

/**********
4.11 类型转换
**********/
4.11.1 隐式转换 (implicit conversion)
算数类型 --> 整型提升，尽量避免精度损失 --> 若无符号类型不小于有符号类型，则转为无符号类型；否则转为有符号类型
数组类型 --> 用于 decltype, &, sizeof, typeid 时，不转为指针；其他情况下转为指针
函数类型 --> 类似于数组
指针类型 --> 0和nullptr可转换成任意指针；指向任意对象的指针可转换成const void*；指向非常量的指针可以转换成void*；派生类指针可转换成基类指针
布尔类型 --> 0->false, else->true
常量转换 --> 指向非常量类型的指针和引用可转换成相应的常量类型指针和引用，反之不行
类类型转换 --> 每次只能执行一种类类型转换 --> string s = "value"; while (cin >> s)

4.11.2 显式转换 (explicit cast)
c++风格  --> cast-name<type>(expression)
函数形式  --> type (expr)
C语言风格 --> (type) expr

1) static_cast, 具有明确意义的类型转换，不包含底层const:
char *cp; string s = static_cast<string>(cp);
可关闭较大类型转较小类型的警告;
可用于void*指针 --> void* p = &d; double *dp = static_cast<double*>(p);

2) const_cast, 只能改变底层const:
const char *pc; string s = const_cast<string>(static_cast<const string>(pc)); --> 正确，但是改变s是未定义的
string a = "value"; string s = const_cast<string>(const_cast<const string>(a)); --> 正确，可以改变s，常用于函数重载

3) reinterpret_cast, 位模式上的低层次重新解释：
int *ip; char *cp = reinterpret_cast<char*>(ip);
本质上依赖于机器

4) dynamic_cast, 
